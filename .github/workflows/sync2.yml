name: Sync2 Open WebUI to Aliyun ACR

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

env:
  SOURCE_REGISTRY: ghcr.io
  SOURCE_NAMESPACE: open-webui
  SOURCE_IMAGE: open-webui
  TARGET_REGISTRY: ${{ secrets.ALIYUN_ACR_REGISTRY }}
  TARGET_NAMESPACE: ${{ secrets.ALIYUN_ACR_NAMESPACE }}

jobs:
  sync-platform-images:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image_type: [default, cuda, cuda126]
        platform: [amd64, arm64]
        include:
          - image_type: default
            source_suffix: ""
            target_name: "open-webui"
          - image_type: cuda
            source_suffix: "-cuda"
            target_name: "open-webui-cuda"
          - image_type: cuda126
            source_suffix: "-cuda126"
            target_name: "open-webui-cuda126"
          - platform: amd64
            platform_full: linux/amd64
          - platform: arm64
            platform_full: linux/arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1. 获取最新版本号
      - name: Get Latest Tag
        id: get-tag
        run: |
          # 尝试从 releases 获取
          LATEST_TAG=$(curl -s -f "https://api.github.com/repos/open-webui/open-webui/releases/latest" | jq -r '.tag_name // empty')
          
          # 如果 releases 为空，尝试从 tags 获取
          if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
            echo "Getting tag from tags list..."
            LATEST_TAG=$(curl -s -f "https://api.github.com/repos/open-webui/open-webui/tags" | jq -r '.[0].name // empty')
          fi
          
          # 如果仍然为空，使用默认值
          if [ -z "$LATEST_TAG" ]; then
            echo "Warning: Could not fetch tag, using default"
            LATEST_TAG="latest"
          fi
          
          echo "Using tag: $LATEST_TAG"
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      # 2. 设置镜像标签变量
      - name: Set image tags
        id: set-tags
        run: |
          # 构建完整的源镜像标签
          SOURCE_TAG="${{ steps.get-tag.outputs.tag }}${{ matrix.source_suffix }}"
          
          # 为目标镜像生成临时平台特定标签（用于后续创建manifest）
          TARGET_TEMP_TAG="${{ steps.get-tag.outputs.tag }}-${{ matrix.platform }}"
          
          echo "source_image_tag=$SOURCE_TAG" >> $GITHUB_OUTPUT
          echo "source_image_full=${{ env.SOURCE_REGISTRY }}/${{ env.SOURCE_NAMESPACE }}/${{ env.SOURCE_IMAGE }}:$SOURCE_TAG" >> $GITHUB_OUTPUT
          echo "target_temp_image=${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/${{ matrix.target_name }}:$TARGET_TEMP_TAG" >> $GITHUB_OUTPUT

      # 3. 登录 GitHub Container Registry
      - name: Login to GitHub Packages
        uses: docker/login-action@v3
        with:
          registry: ${{ env.SOURCE_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 4. 登录阿里云 ACR
      - name: Login to Aliyun ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.TARGET_REGISTRY }}
          username: ${{ secrets.ALIYUN_USERNAME }}
          password: ${{ secrets.ALIYUN_PASSWORD }}

      # 5. 拉取镜像
      - name: Pull Open WebUI Image for ${{ matrix.image_type }} (${{ matrix.platform_full }})
        run: |
          echo "Pulling image: ${{ steps.set-tags.outputs.source_image_full }}"
          docker pull --platform=${{ matrix.platform_full }} ${{ steps.set-tags.outputs.source_image_full }} || \
          echo "Warning: Image may not exist for this platform, continuing..."

      # 6. 重新打标签并推送到临时平台标签
      - name: Tag and Push Platform-specific Image
        run: |
          # 检查镜像是否存在
          if docker inspect ${{ steps.set-tags.outputs.source_image_full }} > /dev/null 2>&1; then
            # 打上平台特定的临时标签
            docker tag ${{ steps.set-tags.outputs.source_image_full }} ${{ steps.set-tags.outputs.target_temp_image }}
            echo "Tagged as: ${{ steps.set-tags.outputs.target_temp_image }}"
            
            # 推送到临时标签
            echo "Pushing platform-specific image: ${{ steps.set-tags.outputs.target_temp_image }}"
            docker push ${{ steps.set-tags.outputs.target_temp_image }}
          else
            echo "Image not available for ${{ matrix.platform }}, skipping"
          fi

      # 7. 清理镜像
      - name: Clean up
        if: always()
        run: |
          docker rmi ${{ steps.set-tags.outputs.source_image_full }} || true
          docker rmi ${{ steps.set-tags.outputs.target_temp_image }} || true
          echo "Cleanup completed for ${{ matrix.target_name }}-${{ matrix.platform }}"

  # 创建多架构 manifest
  create-multiarch-manifests:
    runs-on: ubuntu-latest
    needs: sync-platform-images
    strategy:
      matrix:
        image_type: [default, cuda, cuda126]
        include:
          - image_type: default
            target_name: "open-webui"
          - image_type: cuda
            target_name: "open-webui-cuda"
          - image_type: cuda126
            target_name: "open-webui-cuda126"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get Latest Tag
        id: get-tag
        run: |
          LATEST_TAG=$(curl -s -f "https://api.github.com/repos/open-webui/open-webui/releases/latest" | jq -r '.tag_name // empty')
          if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
            LATEST_TAG=$(curl -s -f "https://api.github.com/repos/open-webui/open-webui/tags" | jq -r '.[0].name // empty')
          fi
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="latest"
          fi
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Login to Aliyun ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.TARGET_REGISTRY }}
          username: ${{ secrets.ALIYUN_USERNAME }}
          password: ${{ secrets.ALIYUN_PASSWORD }}

      - name: Create and push multi-arch manifests
        run: |
          IMAGE_NAME="${{ matrix.target_name }}"
          TAG="${{ steps.get-tag.outputs.tag }}"
          
          echo "Creating multi-arch manifest for $IMAGE_NAME:$TAG"
          
          # 初始化 manifest 命令
          MANIFEST_CMD="docker manifest create ${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:$TAG"
          
          # 添加所有可用的平台
          for PLATFORM in amd64 arm64; do
            TEMP_TAG="$TAG-$PLATFORM"
            IMAGE_REF="${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:$TEMP_TAG"
            
            # 检查镜像是否存在（通过 manifest inspect）
            if docker manifest inspect $IMAGE_REF > /dev/null 2>&1; then
              echo "Adding platform $PLATFORM to manifest"
              MANIFEST_CMD="$MANIFEST_CMD --amend $IMAGE_REF"
            else
              echo "Platform $PLATFORM not available, skipping"
            fi
          done
          
          # 创建 manifest（如果有可用的平台）
          if [ "$MANIFEST_CMD" != "docker manifest create ${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:$TAG" ]; then
            eval $MANIFEST_CMD
            docker manifest push ${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:$TAG
          else
            echo "No platforms available for $IMAGE_NAME:$TAG, skipping manifest creation"
          fi
          
          # 创建 latest manifest
          echo "Creating multi-arch manifest for $IMAGE_NAME:latest"
          LATEST_MANIFEST_CMD="docker manifest create ${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:latest"
          
          for PLATFORM in amd64 arm64; do
            TEMP_TAG="$TAG-$PLATFORM"
            IMAGE_REF="${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:$TEMP_TAG"
            
            if docker manifest inspect $IMAGE_REF > /dev/null 2>&1; then
              echo "Adding platform $PLATFORM to latest manifest"
              LATEST_MANIFEST_CMD="$LATEST_MANIFEST_CMD --amend $IMAGE_REF"
            fi
          done
          
          if [ "$LATEST_MANIFEST_CMD" != "docker manifest create ${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:latest" ]; then
            eval $LATEST_MANIFEST_CMD
            docker manifest push ${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:latest
          else
            echo "No platforms available for $IMAGE_NAME:latest, skipping manifest creation"
          fi

      - name: Clean up temporary platform images
        run: |
          IMAGE_NAME="${{ matrix.target_name }}"
          TAG="${{ steps.get-tag.outputs.tag }}"
          
          # 清理临时平台标签的镜像
          for PLATFORM in amd64 arm64; do
            TEMP_TAG="$TAG-$PLATFORM"
            IMAGE_REF="${{ env.TARGET_REGISTRY }}/${{ env.TARGET_NAMESPACE }}/$IMAGE_NAME:$TEMP_TAG"
            
            # 使用阿里云 ACR API 删除临时标签（可选）
            echo "Temporary image $IMAGE_REF can be cleaned up manually if needed"
          done
